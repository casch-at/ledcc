#ifndef DRAW_HPP
#define DRAW_HPP
#include "Global.hpp"
#include "math.h"
#include <QThread>
#include <QBitArray>
#include <QByteArray>
#include <QVector>
#include <QObject>

volatile const uint8_t lookUpTable[455]  = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x5f,0x5f,0x00,0x00,	//  !
    0x00,0x03,0x00,0x03,0x00,0x14,0x7f,0x14,0x7f,0x14,	// "#
    0x24,0x2a,0x7f,0x2a,0x12,0x23,0x13,0x08,0x64,0x62,	// $%
    0x36,0x49,0x55,0x22,0x50,0x00,0x05,0x03,0x00,0x00,	// &'
    0x00,0x1c,0x22,0x41,0x00,0x00,0x41,0x22,0x1c,0x00,	// ()
    0x14,0x08,0x3e,0x08,0x14,0x08,0x08,0x3e,0x08,0x08,	// *+
    0x00,0x50,0x30,0x00,0x00,0x08,0x08,0x08,0x08,0x08,	// ,-
    0x00,0x60,0x60,0x00,0x00,0x20,0x10,0x08,0x04,0x02,	// ./
    0x3e,0x51,0x49,0x45,0x3e,0x00,0x42,0x7f,0x40,0x00,	// 01
    0x42,0x61,0x51,0x49,0x46,0x21,0x41,0x45,0x4b,0x31,	// 23
    0x18,0x14,0x12,0x7f,0x10,0x27,0x45,0x45,0x45,0x39,	// 45
    0x3c,0x4a,0x49,0x49,0x30,0x01,0x71,0x09,0x05,0x03,	// 67
    0x36,0x49,0x49,0x49,0x36,0x06,0x49,0x49,0x29,0x1e,	// 89
    0x00,0x36,0x36,0x00,0x00,0x00,0x56,0x36,0x00,0x00,	// :;
    0x08,0x14,0x22,0x41,0x00,0x14,0x14,0x14,0x14,0x14,	// <=
    0x00,0x41,0x22,0x14,0x08,0x02,0x01,0x51,0x09,0x06,	// >?
    0x32,0x49,0x79,0x41,0x3e,0x7e,0x11,0x11,0x11,0x7e,	// @A
    0x7f,0x49,0x49,0x49,0x36,0x3e,0x41,0x41,0x41,0x22,	// BC
    0x7f,0x41,0x41,0x22,0x1c,0x7f,0x49,0x49,0x49,0x41,	// DE
    0x7f,0x09,0x09,0x09,0x01,0x3e,0x41,0x49,0x49,0x7a,	// FG
    0x7f,0x08,0x08,0x08,0x7f,0x00,0x41,0x7f,0x41,0x00,	// HI
    0x20,0x40,0x41,0x3f,0x01,0x7f,0x08,0x14,0x22,0x41,	// JK
    0x7f,0x40,0x40,0x40,0x40,0x7f,0x02,0x0c,0x02,0x7f,	// LM
    0x7f,0x04,0x08,0x10,0x7f,0x3e,0x41,0x41,0x41,0x3e,	// NO
    0x7f,0x09,0x09,0x09,0x06,0x3e,0x41,0x51,0x21,0x5e,	// PQ
    0x7f,0x09,0x19,0x29,0x46,0x46,0x49,0x49,0x49,0x31,	// RS
    0x01,0x01,0x7f,0x01,0x01,0x3f,0x40,0x40,0x40,0x3f,	// TU
    0x1f,0x20,0x40,0x20,0x1f,0x3f,0x40,0x38,0x40,0x3f,	// VW
    0x63,0x14,0x08,0x14,0x63,0x07,0x08,0x70,0x08,0x07,	// XY
    0x61,0x51,0x49,0x45,0x43,0x00,0x7f,0x41,0x41,0x00,	// Z[
    0x02,0x04,0x08,0x10,0x20,0x00,0x41,0x41,0x7f,0x00,	// \]
    0x04,0x02,0x01,0x02,0x04,0x40,0x40,0x40,0x40,0x40,	// ^_
    0x00,0x01,0x02,0x04,0x00,0x20,0x54,0x54,0x54,0x78,	// `a
    0x7f,0x48,0x44,0x44,0x38,0x38,0x44,0x44,0x44,0x20,	// bc
    0x38,0x44,0x44,0x48,0x7f,0x38,0x54,0x54,0x54,0x18,	// de
    0x08,0x7e,0x09,0x01,0x02,0x0c,0x52,0x52,0x52,0x3e,	// fg
    0x7f,0x08,0x04,0x04,0x78,0x00,0x44,0x7d,0x40,0x00,	// hi
    0x20,0x40,0x44,0x3d,0x00,0x7f,0x10,0x28,0x44,0x00,	// jk
    0x00,0x41,0x7f,0x40,0x00,0x7c,0x04,0x18,0x04,0x78,	// lm
    0x7c,0x08,0x04,0x04,0x78,0x38,0x44,0x44,0x44,0x38,	// no
    0x7c,0x14,0x14,0x14,0x08,0x08,0x14,0x14,0x18,0x7c,	// pq
    0x7c,0x08,0x04,0x04,0x08,0x48,0x54,0x54,0x54,0x20,	// rs
    0x04,0x3f,0x44,0x40,0x20,0x3c,0x40,0x40,0x20,0x7c,	// tu
    0x1c,0x20,0x40,0x20,0x1c,0x3c,0x40,0x30,0x40,0x3c,	// vw
    0x44,0x28,0x10,0x28,0x44,0x0c,0x50,0x50,0x50,0x3c,	// xy
    0x44,0x64,0x54,0x4c,0x44                        	// z
};

class Draw: public QObject
{
    Q_OBJECT
public:
    Draw();
    ~Draw();
    /***********************************************************************
     *  @brief  Two dimensional array for cube data
     *  cubeFrame[z][y] |= (0x01 << 0) ; where z=y=0
     *  which turns on the first LED at position 000 (x,y,z - Coordinate)
     *  or in other words first layer, first data bit, and first row is
     *  activated.
     ***********************************************************************/
    uint8_t cubeFrame[CUBE_SIZE][CUBE_SIZE];   // [z][y]
    uint8_t cubeFrameTemp[CUBE_SIZE][CUBE_SIZE]; // [z][y]

    CubeArray cubeF;
    CubeArray cubeFTemp;
    void setBixel(int x, int y, int z);
    void setTempBixel(uint8_t x, uint8_t y, uint8_t z);
    void clearBixel(uint8_t x, uint8_t y, uint8_t z);
    void clearTempBixel(uint8_t x, uint8_t y, uint8_t z);
    BixelState getBixelState(uint8_t x, uint8_t y, uint8_t z);
    void flipBixels(uint8_t x, uint8_t y, uint8_t z);
    void alterBixel(uint8_t x, uint8_t y, uint8_t z, BixelState state);

    bool inRange(uint8_t x, uint8_t y, uint8_t z);
    void shift(Axis axis, Direction direction);
    void checkArgumentOrder(uint8_t from, uint8_t to, uint8_t *newStartPoint,
                            uint8_t *newEndPoint);
    void drawPositionAxis(Axis axis, uint8_t position[CUBE_ARRAY_SIZE], bool invert);
    uint8_t flipByte(uint8_t byte);

    void setPlaneZ(uint8_t z);
    void clearPlaneZ(uint8_t z);
    void setPlaneX(uint8_t x);
    void clearPlaneX(uint8_t x);
    void setPlaneY(uint8_t y);
    void clearPlaneY(uint8_t y);
    void setPlane(Axis axis, uint8_t i);
    void clearPlane(Axis axis, uint8_t i);

    void boxWireframe(uint8_t x1, uint8_t y1, uint8_t z1, uint8_t x2,
                      uint8_t y2, uint8_t z2);
    void boxFilled(uint8_t x1, uint8_t y1, uint8_t z1, uint8_t x2, uint8_t y2,
                   uint8_t z2);
    void boxWalls(uint8_t x1, uint8_t y1, uint8_t z1, uint8_t x2, uint8_t y2,
                  uint8_t z2);
    void mirrorX(void);
    void mirrorY(void);
    void mirrorZ(void);
    // @brief Function Prototypes for filling cube array
    void fillTempCubeArray(uint8_t pattern);
    void fillCubeArray(uint8_t pattern);

    uint8_t byteline(uint8_t start, uint8_t end);
    void tmpCubeToCube(void);
    void fontGetChar(uint8_t chr, uint8_t dst[5]);
private:
};

#endif // DRAW_HPP
