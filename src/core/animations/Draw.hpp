/**
 * Copyright (C) 2014  Christian Schwarzgruber <christiandev9@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef DRAW_HPP
#define DRAW_HPP
#include "Global.hpp"
#include "math.h"
#include <QThread>
#include <QBitArray>
#include <QByteArray>
#include <QVector>
#include <QObject>

//QByteArray lookUpT[455];
volatile const u_int8_t lookUpTable[455]  = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x5f,0x5f,0x00,0x00,	//  !
    0x00,0x03,0x00,0x03,0x00,0x14,0x7f,0x14,0x7f,0x14,	// "#
    0x24,0x2a,0x7f,0x2a,0x12,0x23,0x13,0x08,0x64,0x62,	// $%
    0x36,0x49,0x55,0x22,0x50,0x00,0x05,0x03,0x00,0x00,	// &'
    0x00,0x1c,0x22,0x41,0x00,0x00,0x41,0x22,0x1c,0x00,	// ()
    0x14,0x08,0x3e,0x08,0x14,0x08,0x08,0x3e,0x08,0x08,	// *+
    0x00,0x50,0x30,0x00,0x00,0x08,0x08,0x08,0x08,0x08,	// ,-
    0x00,0x60,0x60,0x00,0x00,0x20,0x10,0x08,0x04,0x02,	// ./
    0x3e,0x51,0x49,0x45,0x3e,0x00,0x42,0x7f,0x40,0x00,	// 01
    0x42,0x61,0x51,0x49,0x46,0x21,0x41,0x45,0x4b,0x31,	// 23
    0x18,0x14,0x12,0x7f,0x10,0x27,0x45,0x45,0x45,0x39,	// 45
    0x3c,0x4a,0x49,0x49,0x30,0x01,0x71,0x09,0x05,0x03,	// 67
    0x36,0x49,0x49,0x49,0x36,0x06,0x49,0x49,0x29,0x1e,	// 89
    0x00,0x36,0x36,0x00,0x00,0x00,0x56,0x36,0x00,0x00,	// :;
    0x08,0x14,0x22,0x41,0x00,0x14,0x14,0x14,0x14,0x14,	// <=
    0x00,0x41,0x22,0x14,0x08,0x02,0x01,0x51,0x09,0x06,	// >?
    0x32,0x49,0x79,0x41,0x3e,0x7e,0x11,0x11,0x11,0x7e,	// @A
    0x7f,0x49,0x49,0x49,0x36,0x3e,0x41,0x41,0x41,0x22,	// BC
    0x7f,0x41,0x41,0x22,0x1c,0x7f,0x49,0x49,0x49,0x41,	// DE
    0x7f,0x09,0x09,0x09,0x01,0x3e,0x41,0x49,0x49,0x7a,	// FG
    0x7f,0x08,0x08,0x08,0x7f,0x00,0x41,0x7f,0x41,0x00,	// HI
    0x20,0x40,0x41,0x3f,0x01,0x7f,0x08,0x14,0x22,0x41,	// JK
    0x7f,0x40,0x40,0x40,0x40,0x7f,0x02,0x0c,0x02,0x7f,	// LM
    0x7f,0x04,0x08,0x10,0x7f,0x3e,0x41,0x41,0x41,0x3e,	// NO
    0x7f,0x09,0x09,0x09,0x06,0x3e,0x41,0x51,0x21,0x5e,	// PQ
    0x7f,0x09,0x19,0x29,0x46,0x46,0x49,0x49,0x49,0x31,	// RS
    0x01,0x01,0x7f,0x01,0x01,0x3f,0x40,0x40,0x40,0x3f,	// TU
    0x1f,0x20,0x40,0x20,0x1f,0x3f,0x40,0x38,0x40,0x3f,	// VW
    0x63,0x14,0x08,0x14,0x63,0x07,0x08,0x70,0x08,0x07,	// XY
    0x61,0x51,0x49,0x45,0x43,0x00,0x7f,0x41,0x41,0x00,	// Z[
    0x02,0x04,0x08,0x10,0x20,0x00,0x41,0x41,0x7f,0x00,	// \]
    0x04,0x02,0x01,0x02,0x04,0x40,0x40,0x40,0x40,0x40,	// ^_
    0x00,0x01,0x02,0x04,0x00,0x20,0x54,0x54,0x54,0x78,	// `a
    0x7f,0x48,0x44,0x44,0x38,0x38,0x44,0x44,0x44,0x20,	// bc
    0x38,0x44,0x44,0x48,0x7f,0x38,0x54,0x54,0x54,0x18,	// de
    0x08,0x7e,0x09,0x01,0x02,0x0c,0x52,0x52,0x52,0x3e,	// fg
    0x7f,0x08,0x04,0x04,0x78,0x00,0x44,0x7d,0x40,0x00,	// hi
    0x20,0x40,0x44,0x3d,0x00,0x7f,0x10,0x28,0x44,0x00,	// jk
    0x00,0x41,0x7f,0x40,0x00,0x7c,0x04,0x18,0x04,0x78,	// lm
    0x7c,0x08,0x04,0x04,0x78,0x38,0x44,0x44,0x44,0x38,	// no
    0x7c,0x14,0x14,0x14,0x08,0x08,0x14,0x14,0x18,0x7c,	// pq
    0x7c,0x08,0x04,0x04,0x08,0x48,0x54,0x54,0x54,0x20,	// rs
    0x04,0x3f,0x44,0x40,0x20,0x3c,0x40,0x40,0x20,0x7c,	// tu
    0x1c,0x20,0x40,0x20,0x1c,0x3c,0x40,0x30,0x40,0x3c,	// vw
    0x44,0x28,0x10,0x28,0x44,0x0c,0x50,0x50,0x50,0x3c,	// xy
    0x44,0x64,0x54,0x4c,0x44                        	// z
};

class Draw: public QObject
{
    Q_OBJECT
public:
    explicit Draw(QObject *parent = Q_NULLPTR);
    ~Draw();
    /** @brief CubeArray holds the data of the cube! */
    typedef QVector<QVector<u_int8_t> > CubeArray;

    /************************************************************************
     *                   ENUMERATION DEFENTIONS
     ************************************************************************/
    /** @brief: AXIS TYPE */
    typedef enum
    {
        X_AXIS = 0,
        Y_AXIS,
        Z_AXIS
    } Axis;

    /** @brief: DIRECTION TYPE */
    typedef enum
    {
        BACKWARD = 0,
        FORWARD = !BACKWARD
    } Direction;

    /** @brief: BIXEL STATE */
    typedef enum
    {
        OFF = 0,
        ON = !OFF
    } BixelState;


    CubeArray cubeFrame;
    CubeArray cubeFrameTemp;
protected:
    void setBixel(int x, int y, int z);
    void setTempBixel(u_int8_t x, u_int8_t y, u_int8_t z);

    void clearBixel(u_int8_t x, u_int8_t y, u_int8_t z);
    void clearTempBixel(u_int8_t x, u_int8_t y, u_int8_t z);

    BixelState getBixelState(u_int8_t x, u_int8_t y, u_int8_t z);

    void flipBixels(u_int8_t x, u_int8_t y, u_int8_t z);

    void alterBixel(u_int8_t x, u_int8_t y, u_int8_t z, BixelState state);

    bool inRange(u_int8_t x, u_int8_t y, u_int8_t z);

    void shift(Axis axis, Direction direction);

    void checkArgumentOrder(u_int8_t from, u_int8_t to, u_int8_t *newStartPoint,
                            u_int8_t *newEndPoint);

    void drawPositionAxis(Axis axis, QVector<u_int8_t> &position, bool invert);

    void setPlaneX(u_int8_t x);
    void setPlaneY(u_int8_t y);
    void setPlaneZ(u_int8_t z);
    void setPlane(Axis axis, u_int8_t i);

    void clearPlaneX(u_int8_t x);
    void clearPlaneY(u_int8_t y);
    void clearPlaneZ(u_int8_t z);
    void clearPlane(Axis axis, u_int8_t i);

    void boxWireframe(u_int8_t x1, u_int8_t y1, u_int8_t z1, u_int8_t x2,
                      u_int8_t y2, u_int8_t z2);
    void boxFilled(u_int8_t x1, u_int8_t y1, u_int8_t z1, u_int8_t x2, u_int8_t y2,
                   u_int8_t z2);
    void boxWalls(u_int8_t x1, u_int8_t y1, u_int8_t z1, u_int8_t x2, u_int8_t y2,
                  u_int8_t z2);

    void mirrorX(void);
    void mirrorY(void);
    void mirrorZ(void);

    void fillTempCubeArray(const u_int8_t &pattern);
    void fillCubeArray(const u_int8_t &pattern);

    u_int8_t byteline(const u_int8_t &start, const u_int8_t &end);
    u_int8_t flipByte(u_int8_t byte);

    void tmpCubeToCube(void);

    void fontGetChar(u_int8_t chr, u_int8_t dst[5]);
};
//Q_DECLARE_METATYPE(Draw::AnimationOptions)
#endif // DRAW_HPP
